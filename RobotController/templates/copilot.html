<html>

<head>
  <title>Copilot Monitor</title>
  <!-- CSS Styling -->
  <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/bootstrap.min.css') }}" />
  <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/iconfont/material-icons.css') }}" />
  <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/dashboard.css') }}" />

  <!-- Utilites and Communication -->
  <script type="text/javascript" src="{{ url_for('static', filename='js/jquery-3.4.1.min.js') }}"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='js/jquery.slimscroll.min.js') }}"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='js/socket.io.min.js') }}"></script>

  <!-- Visualization and Display -->
  <script type="text/javascript" src="{{ url_for('static', filename='js/bootstrap.min.js') }}"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='js/dashboard.js') }}"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='js/svg.min.js') }}"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='js/three.js') }}"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='js/GLTFLoader.js') }}"></script>
  <script type="text/javascript" src="{{ url_for('static', filename='js/plotly-latest.min.js') }}"></script>

  <style>
    @font-face {
      font-family: 'Ubuntu-Title';
      src: url("{{ url_for('static', filename='assets/robotDiagram/ubuntu_title/Ubuntu-Title.ttf') }}") format('truetype');
      font-weight: normal;
      font-style: normal;
    }

    #robotDiagramContainer {
      display: grid;
    }

    #robotDiagram-fg {
      width: 100%;
      height: auto;
      z-index: 2;
      grid-column: 1;
      grid-row: 1;
    }

    #robotDiagram-mg {
      width: 100%;
      height: auto;
      z-index: 1;
      grid-column: 1;
      grid-row: 1;
    }

    #robotDiagram-bg {
      background: #303337;
      width: 100%;
      height: auto;
      z-index: 0;
      grid-column: 1;
      grid-row: 1;
    }

    #robot3D {
      width: 400px;
      height: 360px;
    }

    #attitudeSVG {
      width: 100%;
      height: auto;
    }

    #robot3d {
      width: 100%;
      height: auto;
    }

    #graphContainer {
      width: 100%;
    }

    #statDisplay {
      color: #87ceeb;
    }

    .text-redDarkMode {
      color: #fc4646;
    }

    .text-yellowDarkMode {
      color: #fcf046;
    }

    .text-greenDarkMode {
      color: #6efc46;
    }
  </style>
</head>

<body>
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark sticky-top">
    <a class="navbar-brand" href="#">Copilot</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
      aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto">
        <li class="nav-item">
          <a class="nav-link" href="#">Blueshift Robotics</a>
        </li>
      </ul>
    </div>
  </nav>
  <div class="wrapper active d-flex">
    <div class="sideMenu bg-mattBlackLight">
      <div class="sidebar">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a href="/pilot" class="nav-link px-2">
              <i class="material-icons icon">videocam</i>
              <span class="text">Pilot</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="/copilot" class="nav-link px-2">
              <i class="material-icons icon">videogame_asset</i>
              <span class="text">Copilot</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="/cv" class="nav-link px-2">
              <i class="material-icons icon">visibility</i>
              <span class="text">Computer Vision</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link px-2">
              <i class="material-icons icon">settings</i>
              <span class="text">Settings</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="#" class="nav-link px-2 sideMenuToggler">
              <i class="material-icons icon expandView">view_list</i>
              <span class="text">Resize</span>
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="content">
      <main>
        <div style="position: relative; z-index: 1500;">
          <div id="invalidAngleToast" class="toast" data-delay="1000" style="position: absolute; top: 7.5; left: 43%;">
            <div class="toast-header" style="background-color: #6c757d; color: white; border: #6c757d;">
              <h5 class="mr-auto">Please enter a valid angle.</h5>
              <button type="button" class="ml-2 mb-1 close" data-dismiss="toast">
                <span>&times;</span>
              </button>
            </div>
          </div>
          <div id="noCameraToast" class="toast" data-delay="1000" style="position: absolute; top: 7.5; left: 43%;">
            <div class="toast-header" style="background-color: #6c757d; color: white; border: #6c757d;">
              <h5 class="mr-auto">No camera is connected.</h5>
              <button type="button" class="ml-2 mb-1 close" data-dismiss="toast">
                <span>&times;</span>
              </button>
            </div>
          </div>
        </div>
        <div class="container-fluid">
          <div class="row">
            <div class="col-md-3">
              <div class="bg-mattBlackLight my-3 p-3 mx-0 rounded">
                <div id="attitude" class="ml-3"></div>
              </div>
              <div class="bg-mattBlackLight mt-3 px-3 pt-0 pb-3 mx-0 rounded">
                <div id="graphContainer">
                  <div id="temperatureGraph"></div>
                  <div id="speedGraph"></div>
                  <div id="voltageGraph"></div>
                  <div id="amperageGraph"></div>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="bg-mattBlackLight my-3 p-3 mx-0 rounded">
                <div id="robotDiagramContainer">
                  <canvas id="robotDiagram-fg" width="600" height="400"></canvas>
                  <canvas id="robotDiagram-mg" width="600" height="400"></canvas>
                  <canvas id="robotDiagram-bg" width="600" height="400"></canvas>
                </div>
              </div>
              <div class="bg-mattBlackLight my-3 p-3 pb-1 mx-0 rounded">
                <div class="row">
                  <div class="col-md-12">
                    <div class="row mx-3 mb-3 pt-1 bg-mattBlackDark rounded">
                      <div class="col-md-2">
                        <h3 id="statDisplay">FPS: <span id="fpsCounter">0</span></h3>
                      </div>
                      <div class="col-md-3">
                        <h3 id="statDisplay">Control FPS: <span id="earthFpsCounter">0</span></h3>
                      </div>
                      <div class="col-md-3">
                        <h3 id="statDisplay">Mode: <span id="modeDisplay">user-control</span></h3>
                      </div>
                      <div class="col-md-3">
                        <h3 id="statDisplay">Override: <span id="overrideDisplay">false</span></h3>
                      </div>
                    </div>
                  </div>
                  <div class="col-md-3">
                    <button type="button" id="stopMotorsButton" class="btn btn-secondary btn-lg ml-3"
                      style="background-color: #fc4646;"><i class="material-icons icon"
                        style=" font-size: 60px;">block</i></button>
                  </div>
                  <div class="col-md-5">
                    <div class="input-group input-group-lg mb-2">
                      <input type="text" class="form-control" id="xRotInput" placeholder="X: 0">
                      <input type="text" class="form-control" id="yRotInput" placeholder="Y: 0">
                      <input type="text" class="form-control" id="zRotInput" placeholder="Z: 0">
                    </div>
                    <div class="row">
                      <div class="col-md-5">
                        <button type="button" class="btn btn-secondary btn-lg px-0 mx-0" id="holdAngleButton"
                          style="width:100%">Hold
                          Angle</button>
                      </div>
                      <div class="col-md-7">
                        <button type="button" class="btn btn-secondary btn-lg px-0 mx-0" id="rotateToAngleButton"
                          style="width:100%">Rotate
                          To Angle</button>
                      </div>
                    </div>
                    <button type="button" class="btn btn-secondary btn-lg mt-2" id="stabilizeButton">Normalize
                      Rotation</button>
                  </div>
                  <div class="col-md-4">
                    <button type="button" class="btn btn-secondary btn-lg mb-2" id="followTransectLineButton">Follow
                      Transect Line</button>
                    <button type="button" class="btn btn-secondary btn-lg" id="coralReefButton">Analyze Coral
                      Reef</button>
                  </div>
                </div>
              </div>
            </div>
            <div class="col-md-3">
              <div class="bg-mattBlackLight my-3 p-3 mx-0 rounded">
                <div id="robot3D"></div>
              </div>
              <div class="bg-mattBlackLight my-3 p-3 mx-0 rounded ">
                <h3>IMU Calibration</h3>
                <div class="row">
                  <div class="col-md-12">
                    <div id="imu-calib-sys" class="row bg-mattBlackDark rounded my-1 mx-3">
                      <div class="col-md-9">
                        <h1 class="mx-1">System:</h1>
                      </div>
                      <div class="col-md-2">
                        <i class="material-icons icon" id="imu-span-sys" style="font-size: 4em;">block</i>
                      </div>
                    </div>
                    <div id="imu-calib-gyro" class="row bg-mattBlackDark rounded my-1 mx-3">
                      <div class="col-md-9">
                        <h1 class="mx-1">Gyroscope:</h1>
                      </div>
                      <div class="col-md-2">
                        <i class="material-icons icon" id="imu-span-gyro" style="font-size: 4em;">block</i>
                      </div>
                    </div>
                    <div id="imu-calib-accel" class="row bg-mattBlackDark rounded my-1 mx-3">
                      <div class="col-md-9">
                        <h1 class="mx-1">Accelerometer:</h1>
                      </div>
                      <div class="col-md-2">
                        <i class="material-icons icon" id="imu-span-accel" style="font-size: 4em;">block</i>
                      </div>
                    </div>
                    <div id="imu-calib-mag" class="row bg-mattBlackDark rounded my-1 mx-3">
                      <div class="col-md-9">
                        <h1 class="mx-1">Magnetometer:</h1>
                      </div>
                      <div class="col-md-2">
                        <i class="material-icons icon" id="imu-span-mag" style="font-size: 4em;">block</i>
                      </div>
                    </div>
                    <div class="row ml-1 mt-3">
                      <button type="button" class="btn btn-secondary" id="imu-straighten">Straighten</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>
    <script id="attitude_Script">
      var width = 360;
      var height = 360;
      var cx = (width / 2);
      var cy = (height / 2);
      var outerRadius = 30;
      var elementWidth = width * Math.sqrt(2);
      var xOffset = -(elementWidth - 360) / 2;
      var lineWidth = 5;
      var pitchScaleFactor = (width - (2 * outerRadius)) / width;

      /* SVG.js 3.0 */
      var attitudeDisplay = SVG().addTo("#attitude").size(width, height);

      // Setup the svg that was just created for responsive scaling
      var svgElement = document.getElementById("attitude").children[0];
      svgElement.setAttribute("viewBox", "0 0 360 360");
      svgElement.setAttribute("id", "attitudeSVG");

      // Draw the ground and sky inner circle
      var groundInner = attitudeDisplay.rect(elementWidth, height).attr({ fill: '#594218' }).stroke({ color: "#ffffff", width: lineWidth / 2 });
      var skyInner = attitudeDisplay.rect(elementWidth, height).attr({ fill: '#87ceeb' }).stroke({ color: "#ffffff", width: lineWidth / 2 });

      // Draw all of the pitch line and number markings
      var pitchMarkings = [
        attitudeDisplay.line(cx - 30, cy, cx + 30, cy).center(cx, cy + (120 * pitchScaleFactor)).stroke({ color: "#ffffff", width: lineWidth / 2 }),
        attitudeDisplay.text("120").center(cx - 50, cy + (120 * pitchScaleFactor)).fill("#ffffff"), attitudeDisplay.text("120").center(cx + 50, cy + (120 * pitchScaleFactor)).fill("#ffffff"),
        attitudeDisplay.line(cx - 10, cy, cx + 10, cy).center(cx, cy + (90 * pitchScaleFactor)).stroke({ color: "#ffffff", width: lineWidth / 3 }),
        attitudeDisplay.line(cx - 35, cy, cx + 35, cy).center(cx, cy + (60 * pitchScaleFactor)).stroke({ color: "#ffffff", width: lineWidth / 2 }),
        attitudeDisplay.text("60").center(cx - 50, cy + (60 * pitchScaleFactor)).fill("#ffffff"), attitudeDisplay.text("60").center(cx + 50, cy + (60 * pitchScaleFactor)).fill("#ffffff"),
        attitudeDisplay.line(cx - 15, cy, cx + 15, cy).center(cx, cy + (45 * pitchScaleFactor)).stroke({ color: "#ffffff", width: lineWidth / 3 }),
        attitudeDisplay.line(cx - 30, cy, cx + 30, cy).center(cx, cy + (30 * pitchScaleFactor)).stroke({ color: "#ffffff", width: lineWidth / 2 }),
        attitudeDisplay.text("30").center(cx - 45, cy + (30 * pitchScaleFactor)).fill("#ffffff"), attitudeDisplay.text("30").center(cx + 45, cy + (30 * pitchScaleFactor)).fill("#ffffff"),
        attitudeDisplay.line(cx - 15, cy, cx + 15, cy).center(cx, cy + (20 * pitchScaleFactor)).stroke({ color: "#ffffff", width: lineWidth / 2 }),
        attitudeDisplay.line(cx - 10, cy, cx + 10, cy).center(cx, cy + (10 * pitchScaleFactor)).stroke({ color: "#ffffff", width: lineWidth / 3 }),
        attitudeDisplay.line(cx - 10, cy, cx + 10, cy).center(cx, cy + (-10 * pitchScaleFactor)).stroke({ color: "#ffffff", width: lineWidth / 3 }),
        attitudeDisplay.line(cx - 15, cy, cx + 15, cy).center(cx, cy + (-20 * pitchScaleFactor)).stroke({ color: "#ffffff", width: lineWidth / 2 }),
        attitudeDisplay.line(cx - 30, cy, cx + 30, cy).center(cx, cy + (-30 * pitchScaleFactor)).stroke({ color: "#ffffff", width: lineWidth / 2 }),
        attitudeDisplay.text("30").center(cx - 45, cy + (-30 * pitchScaleFactor)).fill("#ffffff"), attitudeDisplay.text("30").center(cx + 45, cy + (-30 * pitchScaleFactor)).fill("#ffffff"),
        attitudeDisplay.line(cx - 15, cy, cx + 15, cy).center(cx, cy + (-45 * pitchScaleFactor)).stroke({ color: "#ffffff", width: lineWidth / 3 }),
        attitudeDisplay.line(cx - 35, cy, cx + 35, cy).center(cx, cy + (-60 * pitchScaleFactor)).stroke({ color: "#ffffff", width: lineWidth / 2 }),
        attitudeDisplay.text("60").center(cx - 50, cy + (-60 * pitchScaleFactor)).fill("#ffffff"), attitudeDisplay.text("60").center(cx + 50, cy + (-60 * pitchScaleFactor)).fill("#ffffff"),
        attitudeDisplay.line(cx - 10, cy, cx + 10, cy).center(cx, cy + (-90 * pitchScaleFactor)).stroke({ color: "#ffffff", width: lineWidth / 3 }),
        attitudeDisplay.line(cx - 30, cy, cx + 30, cy).center(cx, cy + (-120 * pitchScaleFactor)).stroke({ color: "#ffffff", width: lineWidth / 2 }),
        attitudeDisplay.text("120").center(cx - 50, cy + (-120 * pitchScaleFactor)).fill("#ffffff"), attitudeDisplay.text("120").center(cx + 50, cy + (-120 * pitchScaleFactor)).fill("#ffffff")];
      var pitchMarkingLocs = [120, 120, 120, 90, 60, 60, 60, 45, 30, 30, 30, 20, 10, -10, -20, -30, -30, -30, -45, -60, -60, -60, -90, -120, -120, -120];

      // Draw the ground and sky outer circle
      var groundOuter = attitudeDisplay.rect(elementWidth, height).attr({ fill: '#594218' }).stroke({ color: "#ffffff", width: lineWidth });
      var skyOuter = attitudeDisplay.rect(elementWidth, height).attr({ fill: '#87ceeb' }).stroke({ color: "#ffffff", width: lineWidth });

      // Center the ground and sky
      groundInner.move(xOffset, 180);
      skyInner.move(xOffset, -180);
      groundOuter.move(xOffset, 180);
      skyOuter.move(xOffset, -180);

      // Draw all of the pitch markings
      var rollMarkings = [[-60, attitudeDisplay.line(cx, outerRadius / 10, cx, outerRadius).stroke({ color: "#ffffff", width: lineWidth })],
      [-45, attitudeDisplay.circle(lineWidth * 1.25).center(cx, outerRadius / 2).fill("#ffffff")],
      [-30, attitudeDisplay.line(cx, outerRadius / 10, cx, outerRadius).stroke({ color: "#ffffff", width: lineWidth })],
      [-20, attitudeDisplay.line(cx, outerRadius / 2, cx, outerRadius).stroke({ color: "#ffffff", width: lineWidth / 2 })],
      [-10, attitudeDisplay.line(cx, outerRadius / 2, cx, outerRadius).stroke({ color: "#ffffff", width: lineWidth / 2 })],
      [0, attitudeDisplay.polyline([[cx - (outerRadius / 2.5), outerRadius / 10], [cx, outerRadius], [cx + (outerRadius / 2.5), outerRadius / 10], [cx - (outerRadius / 2), outerRadius / 10]]).fill("#ffffff").stroke({ width: 0, color: "#ffffff" })],
      [10, attitudeDisplay.line(cx, outerRadius / 2, cx, outerRadius).stroke({ color: "#ffffff", width: lineWidth / 2 })],
      [20, attitudeDisplay.line(cx, outerRadius / 2, cx, outerRadius).stroke({ color: "#ffffff", width: lineWidth / 2 })],
      [30, attitudeDisplay.line(cx, outerRadius / 10, cx, outerRadius).stroke({ color: "#ffffff", width: lineWidth })],
      [45, attitudeDisplay.circle(lineWidth * 1.25).center(cx, outerRadius / 2).fill("#ffffff")],
      [60, attitudeDisplay.line(cx, outerRadius / 10, cx, outerRadius).stroke({ color: "#ffffff", width: lineWidth })]];

      // Setup and initialize the roll axis
      updateMarkers(0, 1);

      // Create a mask for the inner section
      var maskOuter = attitudeDisplay.mask();
      maskOuter.add(attitudeDisplay.circle(360).fill("#ffffff"));
      maskOuter.add(attitudeDisplay.circle(width - (2 * outerRadius)).dmove(outerRadius, outerRadius).fill("#000000"));
      groundOuter.maskWith(maskOuter);
      skyOuter.maskWith(maskOuter);

      // Create a mask for the outer section
      var maskInner = attitudeDisplay.mask();
      maskInner.add(attitudeDisplay.circle(360).fill("#ffffff"));
      groundInner.maskWith(maskInner);
      skyInner.maskWith(maskInner);

      // Add a shadow gradient to simulate a 3d lens
      var shadowGradient = attitudeDisplay.gradient('radial', function (add) {
        add.stop({ offset: 0, color: "#000000", opacity: 0 })
        add.stop({ offset: 0.5, color: "#000000", opacity: 0.1 })
        add.stop({ offset: 0.75, color: "#000000", opacity: 0.3 })
        add.stop({ offset: 1, color: "#000000", opacity: 1 })
      })

      // Add a light gradient to simulate a 3d lens
      var lightGradient = attitudeDisplay.gradient('radial', function (add) {
        add.stop({ offset: 1 - (2 * outerRadius / width), color: "#ffffff", opacity: 1 })
        add.stop({ offset: (1 - (2 * outerRadius / width)) * 1.07, color: "#ffffff", opacity: 0.3 })
        add.stop({ offset: 1, color: "#ffffff", opacity: 0 })
      })

      // Display and mask the shadow and light gradients
      var shadow = attitudeDisplay.circle(width - (2 * outerRadius)).dmove(outerRadius, outerRadius).fill(shadowGradient).opacity(0.4);
      var light = attitudeDisplay.circle(width).fill(lightGradient).opacity(0.5);
      light.maskWith(maskOuter);

      // Draw the general markings in the center
      var markerColor = "#fc4646";
      var markerStand = attitudeDisplay.polyline([[cx - 10, height], [cx - 1, cy + 40], [cx + 1, cy + 40], [cx + 10, height]]).fill(markerColor).stroke({ color: markerColor, width: lineWidth });
      var markerLine = attitudeDisplay.line(cx, cy, cx, height).stroke({ color: markerColor, width: lineWidth / 1.5 });
      var markerCircle = attitudeDisplay.circle(lineWidth * 2).center(cx, cy).fill(markerColor);
      var orientationGuide = attitudeDisplay.path("M 31.427734,270.96094 H 265.25781 c -4.4e-4,65.73748 53.28987,119.02865 119.02735,119.02929 65.73824,4.4e-4 119.02973,-53.29105 119.02929,-119.02929 h 233.82813").attr({ 'fill-opacity': 0, stroke: markerColor, 'stroke-width': lineWidth * 3.33 }).center(cx, cy + 18).scale(0.3);

      var lastRoll = 0;
      function updateAttitude(gyroData) {
        /*
         * Updates the state of the attitude meter based on gyro data
         * 
         * Arguments:
         *  gyroData: an object containing the the x and y rotation of the robot
         * 
         * Returns:
         *  Nothing
         */
        var roll = gyroData.x - lastRoll; // -180 to 180 (Data from the gyro will probably be 0-360. Check if # is > 180, if so subtract 180 and multiply by -1)
        var pitch = gyroData.y; // ''
        var pScale = 1; // 1-3 (Take max of circular array *1.2? should automatically adjust based on the pitch values)

        pitchScaleFactor = ((width - (2 * outerRadius)) / width) * pScale;
        pitch *= pitchScaleFactor;

        groundInner.rotate(roll, cx, cy);
        skyInner.rotate(roll, cx, cy);
        groundInner.y(pitch + 180);
        skyInner.y(pitch - 180);
        groundOuter.rotate(roll, cx, cy);
        skyOuter.rotate(roll, cx, cy);

        updateMarkers(roll);

        lastRoll = gyroData.x;
      }

      function dist(x1, y1, x2, y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      }

      function updateMarkers(roll, initialize = 0) {
        /*
         * Rotates all of the markers to match an input roll
         *
         * Arguments:
         *  roll: The roll to rotate to
         *  initialize: Whether to initialize the markers
         * 
         * Returns:
         *  Nothing
         */
        for (var i = 0; i < rollMarkings.length; i++) {
          rollMarkings[i][1].rotate(initialize * rollMarkings[i][0] + roll, cx, cy);
        }

        for (var i = 0; i < pitchMarkings.length; i++) {
          pitchMarkings[i].cy(cy + (pitchMarkingLocs[i] * pitchScaleFactor));
        }

        for (var i = 0; i < pitchMarkings.length; i++) {
          pitchMarkings[i].rotate(roll, cx, cy);
          if (dist(cx, cy, pitchMarkings[i].cx(), pitchMarkings[i].cy()) > 160) {
            pitchMarkings[i].opacity(0.0);
          } else {
            pitchMarkings[i].opacity(1.0);
          }
        }
      }
    </script>
    <script id="robot3D_Script">
      // General parameters
      const DEGREES_TO_RADIANS = Math.PI / 180;
      var sceneLoaded = false;
      const camDist = 25;

      // Create a new Three.JS Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x303337);

      // Setup the render
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);

      // Initialize the display
      var container = document.getElementById('robot3D');
      var w = container.offsetWidth;
      var h = container.offsetWidth;
      renderer.setSize(w, h);
      container.appendChild(renderer.domElement);

      // Create a camera
      camera = new THREE.PerspectiveCamera(70, w / h, 1, 1000);

      // Add lights
      hlight = new THREE.AmbientLight(0x404040, 2);
      scene.add(hlight);
      light = new THREE.PointLight(0xc4c4c4, 10);
      light.position.set(0, 300, 500);
      scene.add(light);
      light2 = new THREE.PointLight(0xc4c4c4, 10);
      light2.position.set(500, 100, 0);
      scene.add(light2);
      light3 = new THREE.PointLight(0xc4c4c4, 10);
      light3.position.set(0, 100, -500);
      scene.add(light3);
      light4 = new THREE.PointLight(0xc4c4c4, 10);
      light4.position.set(-500, 300, 500);
      scene.add(light4);

      // Load the robot
      let loader = new THREE.GLTFLoader();
      var fullRobotBody;
      var arrowLoc;
      loader.load("{{ url_for('static', filename='assets/Full-Robot-Body.gltf') }}", function (gltf) {
        // Add the robot to the scene
        scene.add(gltf.scene);
        fullRobotBody = gltf;
        arrowLoc = 20;
        sceneLoaded = true;
      });

      function vectorSize(vec) {
        /* Calculate the magnitude of a vector */
        var sum = 0;
        for (i = 0; i < vec.length; i++) {
          sum += Math.pow(vec[i], 2);
        }
        return Math.sqrt(sum);
      }

      function normalizeVector(vec) {
        /* Make a vector a unit vector*/
        var magnitude = vectorSize(vec);
        var norm = []
        for (i = 0; i < vec.length; i++) {
          norm.push(vec[i] / magnitude);
        }
        return norm;
      }

      function update3D(state) {
        if (sceneLoaded) {
          // Normalize the directin of the arrow
          velVec = [state.vel.x, state.vel.y, state.vel.z];
          velNorm = normalizeVector(velVec);

          // Update the direction of Arrow
          fullRobotBody.scene.children[arrowLoc].rotation.x = Math.acos(velNorm[0]);
          fullRobotBody.scene.children[arrowLoc].rotation.y = Math.asin(velNorm[1]);
          fullRobotBody.scene.children[arrowLoc].rotation.z = Math.atan(velNorm[2]);

          // Update the scale of Arrow
          fullRobotBody.scene.children[arrowLoc].scale.y = (vectorSize(velVec)) / 6 + 0.5;

          // Update the orientation of Camera
          camera.rotation.x = -state.gyro.y * DEGREES_TO_RADIANS;
          camera.rotation.y = state.gyro.z * DEGREES_TO_RADIANS;
          camera.rotation.z = state.gyro.x * DEGREES_TO_RADIANS;
          camera.position.x = 0;
          camera.position.y = 0;
          camera.position.z = 0;
          camera.translateZ(camDist);

          // Render the new frame
          renderer.render(scene, camera);
        }
      }

      function resizeRobot3d() {
        /* Resize the canvas to fit the new window size */

        // Get the new size
        var w = container.offsetWidth;
        var h = container.offsetWidth;

        // Update the camera
        camera.aspect = w / h;
        camera.updateProjectionMatrix();

        // Update the renderer
        renderer.setSize(w, h);
      }

    </script>
    <script id="robotDiagram_Script">
      // TODO: WHAT IS THIS VARIABLE FOR?????????????
      var numLength = 2;

      // TODO: use jquery
      // Setup the canvases for drawing on
      // We use three canvases, so that the whole thing doesn't need to be cleared each time
      // Static element and elements that are updated together have their own canvases
      var canvasFg = document.getElementById('robotDiagram-fg');
      var ctxFg = canvasFg.getContext('2d');

      var canvasMg = document.getElementById('robotDiagram-mg');
      var ctxMg = canvasMg.getContext('2d');

      var canvasBg = document.getElementById('robotDiagram-bg');
      var ctxBg = canvasBg.getContext('2d');

      // Load all the images we need
      var chassis = new Image();
      chassis.src = "{{ url_for('static', filename='assets/robotDiagram/robotDiagram-Chassis.svg') }}";

      var sideThruster = new Image();
      sideThruster.src = "{{ url_for('static', filename='assets/robotDiagram/robotDiagram-SideThruster.svg') }}";

      var sideThrusterPower = new Image();
      sideThrusterPower.src = "{{ url_for('static', filename='assets/robotDiagram/robotDiagram-SideThrusterPower.svg') }}";

      var upThruster = new Image();
      upThruster.src = "{{ url_for('static', filename='assets/robotDiagram/robotDiagram-UpThruster.svg') }}";

      var stillThruster = new Image();
      stillThruster.src = "{{ url_for('static', filename='assets/robotDiagram/robotDiagram-StillThruster.svg') }}";

      var downThruster = new Image();
      downThruster.src = "{{ url_for('static', filename='assets/robotDiagram/robotDiagram-DownThruster.svg') }}";

      var ESCController = new Image();
      ESCController.src = "{{ url_for('static', filename='assets/robotDiagram/robotDiagram-ESC.svg') }}";

      var FathomX = new Image();
      FathomX.src = "{{ url_for('static', filename='assets/robotDiagram/robotDiagram-FathomX.svg') }}";

      var IMUSensor = new Image();
      IMUSensor.src = "{{ url_for('static', filename='assets/robotDiagram/robotDiagram-IMU.svg') }}";

      var PWMController = new Image();
      PWMController.src = "{{ url_for('static', filename='assets/robotDiagram/robotDiagram-PWM.svg') }}";

      var rasPi = new Image();
      rasPi.src = "{{ url_for('static', filename='assets/robotDiagram/robotDiagram-RasPi.svg') }}";

      function drawImg(ctx, img, x, y, degrees = 0, scale = 1, hFlip = 1, vFlip = 1) {
        /* Draws an image at a with a given scale, translation, and orientation */

        // Only draw the image if it is done loading
        if (img.complete) {
          // Save the translation of the canvas so we revert back to it later
          ctx.save();

          // Apply the input transformations
          ctx.translate(x, y);
          ctx.scale(scale, scale);
          ctx.rotate(degrees * Math.PI / 180);
          ctx.scale(hFlip, vFlip);
          var xCoord = roundNumber(-img.width / 2);
          var yCoord = roundNumber(-img.height / 2);

          // Draw the image
          ctx.drawImage(img, xCoord, yCoord, img.width, img.height);

          // Rever back to the old canvas translation
          ctx.restore();
        }
      }

      // Efficient number rounding (https://www.html5rocks.com/en/tutorials/canvas/performance/)
      function roundNumber(num) {
        var rounded = (0.5 + num) | 0;
        rounded = ~~(0.5 + num);
        rounded = (0.5 + num) << 0;
        return rounded
      }

      function drawText(ctx, text, x, y, font, size, color, align, style = "") {
        /* Draws text with an input style */

        // Set the font style
        ctx.fillStyle = color;
        ctx.textAlign = align;
        ctx.font = size.toString() + "px  " + font + " " + style;

        // Set the font alignment
        if (align == "center") {
          ctx.textBaseline = "middle";
        }

        // Draw the text
        ctx.fillText(text, x, y);
      }

      function clearCanvas(ctx, canvas, clearTransforms) {
        /* Clears the canvas */

        // If we don't want to clear the transforms, save the current transform for later
        if (!clearTransforms) ctx.save();

        // Clear the canvas and transforms
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // If we don't want to clear transforms, revert to the transform we saved before
        if (!clearTransforms) ctx.restore();
      }

      function drawTopThruster(ctx, loc, speed, xLoc, yLoc) {
        /* Draws the four vertical thrusters */
        s = 0.65;
        x = 39.5;
        y = 145;
        r = 0;
        v = 1;
        h = 1;
        // Calculate the xy coordinate of the thruster based on its location the robot
        switch (loc) {
          case "TL":
            x *= -1;
            y *= -1;
            break;
          case "TR":
            y *= -1;
            break;
          case "BL":
            x *= -1;
            h *= -1;
            break;
          case "BR":
            h *= -1;
            break;
        }
        // Calculate the xy coordinate of the thruster based on its location the robot
        if (speed > 0) {
          drawImg(ctx, upThruster, xLoc + x, yLoc + y, r, s, v, h);
        } else if (speed == 0) {
          drawImg(ctx, stillThruster, xLoc + x, yLoc + y, r, s, v, h);
        } else {
          drawImg(ctx, downThruster, xLoc + x, yLoc + y, r, s, v, h);
        }

        // Draw the text with the speed of the thruster
        drawText(ctx, Math.trunc(speed * 100.0), xLoc + x, yLoc + (y * 1.51), "Ubuntu-Title", 40, "#D1D1D1", "center");
      }

      function drawSideThruster(ctx, loc, speed, xLoc, yLoc, toDraw) {
        /* Draws the four side thrusters */
        s = 0.65;
        x = 0;
        y = 0;
        r = 0;
        v = 1;
        h = 1;
        xThrust = 7;
        yThrust = 7;
        rThrust = 0;
        vThrust = 1;
        hThrust = 1;

        // Calculate the xy coordinate, rotation, and thrust direction of the thruster based on its location the robot
        switch (loc) {
          case "TL":
            x = xLoc - 160;
            y = yLoc - 135;
            r = -45;
            xThrust *= -1;
            yThrust *= -1;
            rThrust = r;
            break;
          case "TR":
            x = xLoc + 165;
            y = yLoc - 132;
            r = 45;
            yThrust *= -1;
            rThrust = r;
            break;
          case "BL":
            x = xLoc - 160;
            y = yLoc + 135;
            r = 45;
            xThrust *= -1;
            h = -1;
            rThrust = r;
            break;
          case "BR":
            x = xLoc + 165;
            y = yLoc + 132;
            r = -45;
            h = -1;
            rThrust = r;
            break;
        }


        // Draw the thruster or the thrust itself depending on the input
        if (toDraw == "part") {
          // Draw the thruster
          drawImg(ctx, sideThruster, x, y, r, s, v, h);
        } else if (toDraw == "thrust") {
          // Normalize the speed
          if (speed != 0) {
            vThrust = Math.abs(speed);
            if (speed < 0) {
              rThrust = 180 + rThrust;

            }

            // Draw the thrust coming out of the robot
            drawImg(ctx, sideThrusterPower, x + xThrust, y + yThrust, rThrust, s, vThrust, hThrust);
          }
          // Draw text with the speed
          drawText(ctx, Math.trunc(speed * 100.0), x + (xThrust * 9), y + (yThrust * 9), "Ubuntu-Title", 40, "#D1D1D1", "center");
        }
      }

      function drawDevice(ctx, devName, working, xLoc, yLoc) {
        /* Draws the electronics in the tube */
        x = xLoc;
        y = yLoc;
        s = 1;
        r = 0;

        // Get the location and image of component based on its name
        image = new Image();
        switch (devName) {
          case "ESC":
            image = ESCController;
            s = 0.32;
            x = xLoc - 75;
            y = yLoc + 15;
            break;
          case "IMU":
            image = IMUSensor;
            s = 0.15;
            x = xLoc - 75;
            y = yLoc - 28;
            break;
          case "FathomX":
            image = FathomX;
            s = 0.2;
            x = xLoc + 75;
            y = yLoc;
            break;
          case "PWM":
            image = PWMController;
            s = 0.24;
            x = xLoc;
            y = yLoc + 25;
            break;
          case "RasPi":
            image = rasPi;
            s = 0.3;
            x = xLoc;
            y = yLoc - 17;
            break;
        }

        if (working) {
          // Draw the component
          drawImg(ctx, image, x, y, r, s);
        } else {
          // Apply a red filter if the component is not operational
          ctx.filter = "sepia(100%) saturate(250%) hue-rotate(-50deg)";

          // Draw the component and reset the filter
          drawImg(ctx, image, x, y, r, s);
          ctx.filter = "none";
        }
      }

      function remapArray(arr, oldMin, oldMax, newMin, newMax) {
        /* Remaps an array */
        mapped = [];
        for (i = 0; i < arr.length; i++) {
          mapped.push(newMin + (newMax - newMin) * (arr[i] - oldMin) / (oldMax - oldMin));
        }
        return mapped;
      }

      // Scale the midground canvas
      scaleAmnt = 0.7;
      xLoc = ((canvasFg.width / 2) / scaleAmnt);
      yLoc = (canvasFg.height / 2) / scaleAmnt;

      ctxMg.scale(scaleAmnt, scaleAmnt);

      function drawRobotDiagramStatic() {
        /* Draw the static parts of the robot diagram */
        drawSideThruster(ctxMg, "TL", 0, xLoc, yLoc, "part");
        drawSideThruster(ctxMg, "TR", 0, xLoc, yLoc, "part");
        drawSideThruster(ctxMg, "BL", 0, xLoc, yLoc, "part");
        drawSideThruster(ctxMg, "BR", 0, xLoc, yLoc, "part");
        drawImg(ctxMg, chassis, xLoc, yLoc, 0, 1.5);
      }

      function truncateArrayEntries(arr, decimals = 2) {
        /* Truncate extra numbers after the decimal on each element in an array */
        var pow = Math.pow(10, decimals);
        for (var i = 0; i < arr.length; i++) {
          arr[i] = Math.trunc(arr[i] * pow) / pow;
        }
        return arr
      }

      function updateDiagram(speeds) {
        // Clear the foreground and background canvases
        clearCanvas(ctxFg, canvasFg, true);
        clearCanvas(ctxBg, canvasBg, true);

        // Scale the midground canvas
        ctxFg.scale(scaleAmnt, scaleAmnt);
        ctxBg.scale(scaleAmnt, scaleAmnt);


        // Draw the only the thrust of the side thrusters
        drawSideThruster(ctxBg, "TL", speeds[2], xLoc, yLoc, "thrust");
        drawSideThruster(ctxBg, "TR", speeds[0], xLoc, yLoc, "thrust");
        drawSideThruster(ctxBg, "BL", speeds[3], xLoc, yLoc, "thrust");
        drawSideThruster(ctxBg, "BR", speeds[1], xLoc, yLoc, "thrust");

        // Draw the top thrusters
        drawTopThruster(ctxBg, "TL", speeds[6], xLoc, yLoc);
        drawTopThruster(ctxBg, "TR", speeds[4], xLoc, yLoc);
        drawTopThruster(ctxBg, "BL", speeds[7], xLoc, yLoc);
        drawTopThruster(ctxBg, "BR", speeds[5], xLoc, yLoc);

        // Draw all of the devices
        drawDevice(ctxFg, "ESC", true, xLoc, yLoc);
        drawDevice(ctxFg, "FathomX", true, xLoc, yLoc);
        drawDevice(ctxFg, "IMU", true, xLoc, yLoc);
        drawDevice(ctxFg, "PWM", true, xLoc, yLoc);
        drawDevice(ctxFg, "RasPi", true, xLoc, yLoc);
      }
    </script>
    <script id="realtimeGraphs_Script">
      // TODO: use jquery
      var graphContainer = document.getElementById("graphContainer");

      // Style the graph
      var layout = {
        showlegend: true,
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        width: graphContainer.offsetWidth,
        height: (window.innerHeight - window.innerWidth * 0.272) / 4,
        margin: {
          l: 25,
          r: 25,
          b: 25,
          t: 25,
          pad: 4
        },
        legend: {
          x: 0,
          y: 1.5,
          font: {
            family: 'Arial',
            size: 14,
            color: '#808080'
          }
        },
        xaxis: {
          showgrid: true,
          zeroline: false,
          showline: false,
          mirror: 'ticks',
          gridcolor: '#808080',
          gridwidth: 2,
          zerolinecolor: '#969696',
          zerolinewidth: 4,
          linecolor: '#636363',
          linewidth: 6,
          tickfont: {
            family: 'Arial',
            size: 14,
            color: '#808080'
          },
          range: [500, 0]
        },
        yaxis: {
          showgrid: true,
          zeroline: false,
          showline: false,
          mirror: 'ticks',
          gridcolor: '#808080',
          gridwidth: 2,
          zerolinecolor: '#969696',
          zerolinewidth: 4,
          linecolor: '#636363',
          linewidth: 6,
          tickfont: {
            family: 'Arial',
            size: 14,
            color: '#808080'
          },
        }
      };

      // Settings for the graph
      settings = {
        displayModeBar: false
      };


      // Initialize the amperage graph
      var amperageData = [
        {
          y: [0],
          type: 'scatter',
          line: {
            shape: 'spline',
            smoothing: 1,
            color: '#6efc46'
          },
          name: "Amps"
        }
      ];
      // TODO: Write a copy functin and replace the messy JSON code
      // When the graph is created
      // we make a copy of the settings so that they can be changed without affecting the other graphs

      // Setup the amperage graph
      Plotly.plot('amperageGraph', amperageData, JSON.parse(JSON.stringify(layout)), settings);
      Plotly.relayout('amperageGraph', { yaxis: { range: [0, 30] } });

      // Initialize the voltage graph
      var voltageData = [
        {
          y: [0],
          type: 'scatter',
          line: {
            shape: 'spline',
            smoothing: 1,
            color: '#fcf046'
          },
          name: "Volts"
        }
      ];

      // Setup the voltage graph
      Plotly.plot('voltageGraph', voltageData, JSON.parse(JSON.stringify(layout)), settings);
      Plotly.relayout('voltageGraph', { yaxis: { range: [0, 15] } });

      // Initialize the speed graph
      var speedData = [
        {
          y: [0],
          type: 'scatter',
          line: {
            shape: 'spline',
            smoothing: 1,
            color: '#e08c3e'
          },
          name: "Speed"
        }
      ];

      // Setup the speed graph
      Plotly.plot('speedGraph', speedData, JSON.parse(JSON.stringify(layout)), settings);
      Plotly.relayout('speedGraph', { yaxis: { range: [0, 30] } });

      // Initialize the temperature graph
      var temperatureData = [
        {
          y: [0],
          type: 'scatter',
          line: {
            shape: 'spline',
            smoothing: 1,
            color: '#fc4646'
          },
          name: "Temp"
        }
      ];

      // Setup the temperature graph
      Plotly.plot('temperatureGraph', temperatureData, JSON.parse(JSON.stringify(layout)), settings);
      Plotly.relayout('temperatureGraph', { yaxis: { range: [10, 30] } });

      // Set the current and max number of items per graph
      var cnt = 1;
      var maxCnt = 50;

      // Add new data to the graphs and delete the old data
      function updateGraphs(sensors) {
        // Add new data to all of the graphs
        Plotly.prependTraces(
          'amperageGraph',
          {
            y: [[sensors.amps]]
          },
          [0]
        );

        Plotly.prependTraces(
          'voltageGraph',
          {
            y: [[sensors.volts]]
          },
          [0]
        );

        Plotly.prependTraces(
          'speedGraph',
          {
            y: [[vectorSize([sensors.imu.vel.x, sensors.imu.vel.y, sensors.imu.vel.z])]]
          },
          [0]
        );

        Plotly.prependTraces(
          'temperatureGraph',
          {
            y: [[sensors.temp]]
          },
          [0]
        );

        // Remove old data from all of the graphs
        cnt++;
        if (cnt > maxCnt) {
          amperageData[0].y.pop();
          voltageData[0].y.pop();
          speedData[0].y.pop();
          temperatureData[0].y.pop();
          cnt--;
        }
        
        // Update all of the graphs with the new range
        Plotly.relayout('amperageGraph', {
          'xaxis.range': [cnt, 0]
        });

        Plotly.relayout('voltageGraph', {
          'xaxis.range': [cnt, 0]
        });

        Plotly.relayout('speedGraph', {
          'xaxis.range': [cnt, 0]
        });

        Plotly.relayout('temperatureGraph', {
          'xaxis.range': [cnt, 0]
        });
      }

      function resizeGraphs() {
        /* Resize the graphs to fit the new window size */
        var w = graphContainer.offsetWidth;
        var h = (window.innerHeight - window.innerWidth * 0.28) / 4;
        Plotly.relayout('amperageGraph', {
          'width': w,
          'height': h
        });

        Plotly.relayout('voltageGraph', {
          'width': w,
          'height': h
        });

        Plotly.relayout('speedGraph', {
          'width': w,
          'height': h
        });

        Plotly.relayout('temperatureGraph', {
          'width': w,
          'height': h
        });
      }
    </script>
    <script id="console_Script">
      // Timestamp to keep track of FPS
      var lastLoop = new Date();

      // Update the console with the new data
      function updateConsole(mode, override, earthFpsCounter) {
        var thisLoop = new Date();
        var fps = 1000 / (thisLoop - lastLoop);
        lastLoop = thisLoop;
        $("#fpsCounter").text(fps.toFixed(1));
        $("#earthFpsCounter").text(earthFpsCounter.toFixed(1));
        $("#modeDisplay").text(mode);
        $("#overrideDisplay").text(override);
      }
    </script>
    <script id="main_Script">
      // TODO: Move all of the separate widgets into separate flask files
      // Also use flask inheritance to have a separate file for the general dashboard parts
      $(document).ready(function () {
        // Create a websocket connection with the Earth Node
        var socket = io.connect('http://' + document.domain + ':' + location.port);

        // Setup an event handler for when messages are recieved
        socket.on('updateAirNode', handleUpdates);

        // Variables to track the state of the system
        var controlMode = "user-control";
        var userOverride = "false";
        var earthFps = 0;
        var sensorData = {
          "imu": {
            "calibration": {
              "sys": 0,
              "gyro": 0,
              "accel": 0,
              "mag": 0
            },
            "gyro": {
              "x": 0,
              "y": 0,
              "z": 0,
            },
            "vel": {
              "x": 0,
              "y": 0,
              "z": 0,
            }
          },
          "temp": 0
        };

        var drivetrainSpeeds = new Array(8).fill(0);


        function handleUpdates(parsed) {
          /* Handle messages from the Earth Node */
          switch (parsed.tag) {
            case "log":
              console.log(parsed.data);
              if (parsed.metadata == "earth-fps") {
                earthFps = parsed.data;
              }
              break;
            case "sensor":
              sensorData = parsed.data;
              break;
            case "motorData":
              if (parsed.metadata == "drivetrain") {
                drivetrainSpeeds = truncateArrayEntries(parsed.data);
              }
              break;
            case "stateChange":
              if (parsed.metadata == "mode") {
                controlMode = parsed.data;
              } else if (parsed.metadata == "override") {
                userOverride = parsed.data;
              } else if (parsed.metadata == "follow-line") {
                if (parsed.data == "noCamera") {
                  $('#noCameraToast').toast('show');
                }
              }
              break;
          }
        }

        // List elements to display the IMU calibration status
        // TODO: Switch to JQuery
        var imuCalibSys = document.getElementById("imu-calib-sys");
        var imuSpanSys = document.getElementById("imu-span-sys");

        var imuCalibGyro = document.getElementById("imu-calib-gyro");
        var imuSpanGyro = document.getElementById("imu-span-gyro");

        var imuCalibAccel = document.getElementById("imu-calib-accel");
        var imuSpanAccel = document.getElementById("imu-span-accel");

        var imuCalibMag = document.getElementById("imu-calib-mag");
        var imuSpanMag = document.getElementById("imu-span-mag");

        function updateSite() {
          /* This is the main control loop of the site */

          // TODO: Test with requestAnimationFrame at the beginning of this function
          // Tested this, for some reason it nearly cut the fps in half, not a sure why
          // Switching back to the original

          // Ask the air node for new data
          socket.emit("getAirNodeUpdates", Date.now());

          // TODO: Switch to jquery
          // Update the calibration status of the IMU
          for (const [part, status] of Object.entries(sensorData.imu.calibration)) {
            var selectedCalib;
            var selectedSpan;

            switch (part) {
              case "sys":
                selectedCalib = imuCalibSys;
                selectedSpan = imuSpanSys;
                break;
              case "gyro":
                selectedCalib = imuCalibGyro;
                selectedSpan = imuSpanGyro;
                break;
              case "accel":
                selectedCalib = imuCalibAccel;
                selectedSpan = imuSpanAccel;
                break;
              case "mag":
                selectedCalib = imuCalibMag;
                selectedSpan = imuSpanMag;
                break;
            }

            selectedCalib.classList.remove("text-greenDarkMode");
            selectedCalib.classList.remove("text-yellowDarkMode");
            selectedCalib.classList.remove("text-redDarkMode");

            switch (status) {
              case 0:
                selectedCalib.classList.add("text-redDarkMode");
                selectedSpan.innerHTML = "cancel";
                break;
              case 1:
              case 2:
                selectedCalib.classList.add("text-yellowDarkMode");
                selectedSpan.innerHTML = "cached";
                break;
              case 3:
                selectedCalib.classList.add("text-greenDarkMode");
                selectedSpan.innerHTML = "check";
                break;
            }
          }

          // Update Visualizations
          //update3D(sensorData.imu);
          updateAttitude(sensorData.imu.gyro);
          updateGraphs(sensorData);
          updateDiagram(drivetrainSpeeds);
          updateConsole(controlMode, userOverride, earthFps);

          // Call this function again in a loop
          requestAnimationFrame(updateSite);
        }

        // TODO: Maybe switch this to just calling update?
        // This works, the changes has been made
        updateSite();

        // IMU Calibration Event Handler
        $('#imu-straighten').click(function () {
          var packet = {
            "tag": "settingChange",
            "data": sensorData.imu.gyro,
            "timestamp": Date.now() / 1000 | 0,
            "metadata": "imuStraighten",
            "highPriority": false
          }
          // Send a command to straighten the IMU
          socket.emit("sendUpdate", packet);
        });

        // Rotate Robot to Specific Angle event handler
        $('#rotateToAngleButton').click(function () {
          var xAngle = Number($('#xRotInput').val());
          var yAngle = Number($('#yRotInput').val());
          var zAngle = Number($('#zRotInput').val());

          // Make sure that each of the text boxes actually contain a number
          if (!Number.isNaN(xAngle) && !Number.isNaN(yAngle) && !Number.isNaN(zAngle)) {
            var packet = {
              "tag": "stateChange",
              "data": {
                "x": xAngle,
                "y": yAngle,
                "z": zAngle
              },
              "timestamp": Date.now() / 1000 | 0,
              "metadata": "stabilize",
              "highPriority": false
            }
            // Send a command to stabilize the robot to a specific angle
            socket.emit("sendUpdate", packet);
          } else {
            $('#invalidAngleToast').toast('show');
          }
        });

        $('#stabilizeButton').click(function () {
          var packet = {
            "tag": "stateChange",
            "data": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "timestamp": Date.now() / 1000 | 0,
            "metadata": "stabilize",
            "highPriority": false
          }
          // Send a command to stabilize the robot to a (0,0,0)
          socket.emit("sendUpdate", packet);
        });

        $('#stopMotorsButton').click(function () {
          var packet = {
            "tag": "stateChange",
            "data": "",
            "timestamp": Date.now() / 1000 | 0,
            "metadata": "stop-motors",
            "highPriority": false
          }
          // Send a command to stop the motors
          socket.emit("sendUpdate", packet);
        });

        $('#followTransectLineButton').click(function () {
          var packet = {
            "tag": "stateChange",
            "data": "run",
            "timestamp": Date.now() / 1000 | 0,
            "metadata": "follow-line",
            "highPriority": false
          }

          // Send a command to start following the transect line
          console.log(packet)
          socket.emit("sendUpdate", packet);
        });

        $('#coralReefButton').click(function () {
          var packet = {
            "tag": "stateChange",
            "data": "run",
            "timestamp": Date.now() / 1000 | 0,
            "metadata": "analyze-coral-reef",
            "highPriority": false
          }
          // Send a command to run the coral reef algorithm
          socket.emit("sendUpdate", packet);
        });

        $('#holdAngleButton').click(function () {
          if (controlMode != "hold-angle") {
            var xAngle = Number($('#xRotInput').val());
            var yAngle = Number($('#yRotInput').val());
            var zAngle = Number($('#zRotInput').val());

            // Make sure that each of the text boxes actually contain a number
            if (!Number.isNaN(xAngle) && !Number.isNaN(yAngle) && !Number.isNaN(zAngle)) {
              var packet = {
                "tag": "stateChange",
                "data": {
                  "x": xAngle,
                  "y": yAngle,
                  "z": zAngle
                },
                "timestamp": Date.now() / 1000 | 0,
                "metadata": "hold-angle",
                "highPriority": false
              }
              // Send a command to hold the input angle
              socket.emit("sendUpdate", packet);
            } else {
              $('#invalidAngleToast').toast('show');
            }
          } else {
            var packet = {
              "tag": "stateChange",
              "data": "",
              "timestamp": Date.now() / 1000 | 0,
              "metadata": "stop-motors",
              "highPriority": false
            }
            socket.emit("sendUpdate", packet);
          }

        });

        // Auto resize canvas in case of window size change
        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
          resizeRobot3d();
          resizeGraphs();
        }

        // Draw static elements once they have been loaded
        window.onload = function () {
          drawRobotDiagramStatic();
        }
      });
    </script>
</body>

</html>